---
title: Integrating Secrets
description: Discover how to leverage the incredibly useful but optional integrations that Install Doctor supports by integrating variables in the form of environment variables and encrypted secrets into your own custom fork.
sidebar_label: Secrets
slug: /customization/secrets
---

Install Doctor implements many optional features that rely on user-specific variables. Most of these user-specific variables are API keys. To augment that capabilities of your device, Install Doctor can leverage API keys to many free and popular cloud services. These API keys, as well as other user-specific variables, can be utilized by defining them as environment variables prior to running the start script. It is also possible to encrypt and bundle some of these secrets into your own fork of the Install Doctor repository.

## Environment Variables

The easiest way to get started with automating the Install Doctor provisioning process and leveraging optional features is to define user-specific variables as environment variables.

For instance, if you want to automate the provisioning process the first time you run the Install Doctor quick start script (without deep diving into all the variables yet), you can run the following (depending on your operating system):

**Linux / macOS:**

```shell
export HEADLESS_INSTALL=true
export SOFTWARE_GROUP=Standard-Desktop
export FULL_NAME="Joe Shmoe"
export PRIMARY_EMAIL="help@megabyte.space"
export PUBLIC_SERVICES_DOMAIN="megabyte.space"
export START_REPO=my-gh-user/my-fork-name
bash <(curl -sSL https://install.doctor/start)
```

**Windows:**

```shell
$env:HEADLESS_INSTALL = true
$env:SOFTWARE_GROUP = Standard-Desktop
$env:FULL_NAME = 'Joe Shmoe'
$env:PRIMARY_EMAIL = 'help@megabyte.space'
$env:PUBLIC_SERVICES_DOMAIN = 'megabyte.space'
$env:START_REPO = 'my-gh-user/my-fork-name'
iex ((New-Object System.Net.WebClient).DownloadString('https://install.doctor/windows'))
```

**Qubes:**

```shell
export HEADLESS_INSTALL=true
export SOFTWARE_GROUP=Standard-Desktop
export FULL_NAME="Joe Shmoe"
export PRIMARY_EMAIL="help@megabyte.space"
export PUBLIC_SERVICES_DOMAIN="megabyte.space"
export START_REPO=my-gh-user/my-fork-name
qvm-run --pass-io sys-firewall "curl -sSL https://install.doctor/qubes" > ~/setup.sh
bash ~/setup.sh
```

Running the blocks of code listed above will bypass the Install Doctor TUI prompt system, allowing a completely headless setup process for your device.

There are many other variables you can make use of which are detailed in one of the following sections below.

## Encrypted Secrets

For added security and convienience, Install Doctor supports embedding your secret variables into your own fork of Install Doctor by encrypting them with the [Chezmoi](https://www.chezmoi.io/) default encryption provider called [Age](https://github.com/FiloSottile/age). By using this method, you will no longer have to manage a long set of environment variables and you will be able to store your encrypted secrets in a public git that you can use to provision any of your devices.

**The first thing you should do when leveraging your own Age encryption key in your own fork of Install Doctor is to delete all the keys stored in the `home/.chezmoitemplates/secrets/` folder.** If you do not do this, then Install Doctor will try unencrypting the test secrets using your key.

### Creating an Age Key (Password Protected)

Install Doctor's default recommended encryption method involves:

1. Creating a password protected Age encryption key
2. Using the encryption key to encrypt your variables which are stored in `home/.chezmoitemplates/secrets/`

To create an encryption key, first ensure Age is installed and available in your PATH (the quick start script will automatically install Homebrew / Age). With `age` available from your terminal, run the following:

```shell
age-keygen | age -p > key.age
```

The output should look something like the following if you decided to forego creating a custom password:

```text
Public key: age1wzpkjhk6jtgq2d3q97jdq7ptwpra7kdplnt38p5ruetcwfzahvps40l6a5
age: using autogenerated passphrase "act-client-permit-coil-clinic-cushion-wheat-beauty-ski-alarm"
```

Make note of the public key and your password. The public key should be added to the `home/.chezmoi.yaml.tmpl` file under the `age.recipient` key (just search for, "recipient" in the file). The `key.age` file that was generated should be added to `home/key.txt.age`. The quick start script that Install Doctor hosts expects the key to be stored in `home/key.txt.age`.

With all of this done, you can commit your changes. Your `key.txt.age` file is useless to anyone who does not know the password to decrypt it. The Install Doctor start script (that you can find on the homepage) will prompt you to decrypt the `key.txt.age` file using your selected password and store it in the location specified in the `home/.chezmoi.yaml.tmpl` file. For automation purposes, if you are using the default `home/.chezmoi.yaml.tmpl` file settings, the unencrypted file is temporarily stored on the disk in the `$HOME/.config/age/chezmoi.txt` location. This makes it easier to re-run the provisioning process and add new secrets to your custom fork. **After you are done using the encryption key, you should delete the unencrypted Age key file stored at `$HOME/.config/age/chezmoi.txt`.**

### Adding Secrets Using the Age Key

To add secrets to your custom fork, you need to ensure Chezmoi is configured to use the file stored in `$HOME/.config/age/chezmoi.txt` that is decrypted using a password from the file stored in `home/key.txt.age` of your custom fork. The easiest way to do this for the first time is to ensure the `START_REPO` environment variable is pointing to your custom fork and run the quick start script:

**Linux / macOS:**

```shell
export START_REPO=my-gh-user/my-fork-name
bash <(curl -sSL https://install.doctor/start)
```

**Windows:**

```powershell
$env:START_REPO = 'my-gh-user/my-fork-name'
iex ((New-Object System.Net.WebClient).DownloadString('https://install.doctor/windows'))
```

**Qubes:**

```shell
export START_REPO=my-gh-user/my-fork-name
qvm-run --pass-io sys-firewall "curl -sSL https://install.doctor/qubes" > ~/setup.sh
bash ~/setup.sh
```

Early in the provisioning process, the script will prompt you for your Age encryption passphrase. After this happens, you can CTRL+C out of the script and begin adding your encrypted secrets to your git repository fork.

With Chezmoi and Age configured, you can now begin encrypting all the pieces of data that you do not want to have to pass in as environment variables. You can also encrypt other things like SSH keys, GPG keys, etc.

#### Encrypting an API Key

To encrypt an API key, you would run:

```shell
echo "apikey-xXxxXxX" | chezmoi encrypt
```

The resulting text that outputs to the terminal would look something like this:

```text
-----BEGIN AGE ENCRYPTED FILE-----
YWdlLWVuY3J5cHRpb24ub3JnL3YxCi0+IFgyNTUxOSBCamNtb0pvOFRmYXRyNEhY
R1BpS09IYVBSSG83Rmh2MVJpdExKdjZrY2hVCmRmTTdjUDJyU2ZZK0NObmUwZ0dH
eGtFQUV6NXVPdjR1WFljNUkyczZuVjAKLS0tIDVTZDFPLytQVTJMNStUK21KYVF4
QVBhb0hIMG9tRjVuYWlHejN4cDJrQkkKTx7EQBmWL+0mXeaOOAtqo9rbJjWYx7mj
Jr4Trf/qfrmiDXX/
-----END AGE ENCRYPTED FILE-----
```

Copy the text including the lines that contain `BEGIN AGE ENCRYPTED FILE` and `END AGE ENCRYPTED FILE` and store them into the appropriate file nested inside `home/.chezmoitemplates/secrets/`. You can determine the supported key file names by referring to the Supported Variables / Secrets Table below.

#### Encrypting a File

To encrypt an entire file (named `myfile.ext` in the following example), you can run:

```shell
chezmoi encrypt myfile.ext
```

The resulting encrypted text can then be copied / pasted into the appropriate key file location. Supported targets are listed below in the Supported Variables / Secrets Table section.

### Using GPG

If you prefer to use GPG instead of Age as your encryption mechanism, you can define this option in the `home/.chezmoi.yaml.tmpl` file. For more details on this implementation, see the [GPG page in the Chezmoi docs](https://www.chezmoi.io/user-guide/encryption/gpg/).

Users may want to do this so they can protect their secrets with hardware-backed encryption via devices like a YubiKey. For details on how to setup GPG with a YubiKey, refer to [this guide](https://github.com/drduh/YubiKey-Guide).

## Supported Variables / Secrets Table

The following table details all the custom variables supported by Install Doctor.

*This chart is a work in progress.*

| Environment Variable | Secret File | Description  |
|----------------------|-------------|---|
| `ANSIBLE_GALAXY_TOKEN`                     | `key-ANSIBLE_GALAXY_TOKEN`            | Ansible Galaxy API token stored in `$HOME/.config/shell/private.sh`  |
| `ANSIBLE_VAULT_PASSWORD`            | `key-ANSIBLE_VAULT_PASSWORD`            | Ansible Vault password stored in `$HOME/.config/shell/private.sh`  |
| `DOCKERHUB_TOKEN`                     | `key-DOCKERHUB_TOKEN`            | DockerHub API token stored in `$HOME/.config/shell/private.sh`  |
| `GITHUB_TOKEN` | `key-GITHUB_TOKEN` | GitHub personal access token stored in `$HOME/.config/shell/private.sh` and also used to create backup of GitHub repositories using Ghorg |
| `GITLAB_TOKEN` | `key-GITLAB_TOKEN` | GitLab personal access token stored in `$HOME/.config/shell/private.sh` and also used to create backup of GitLab repositories using Ghorg |
| `HEROKU_API_KEY` | `key-HEROKU_API_KEY` | Heroku API token stored in `$HOME/.config/shell/private.sh` |
| `NPM_TOKEN` | `key-NPM_TOKEN` | NPM API token stored in `$HOME/.config/shell/private.sh` |
| `PYPI_TOKEN` | `key-PYPI_TOKEN` | PyPi.org API token stored in `$HOME/.config/shell/private.sh` |
| `SNAPCRAFT_MACAROON` | `key-SNAPCRAFT_MACAROON` | Snapcraft.io authentication variable stored in `$HOME/.config/shell/private.sh` |
| `SNAPCRAFT_UNBOUND_DISCHARGE` | `key-SNAPCRAFT_UNBOUND_DISCHARGE` | Snapcraft.io authentication variable stored in `$HOME/.config/shell/private.sh` |
| `VAGRANT_CLOUD_TOKEN` | `key-VAGRANT_CLOUD_TOKEN` | VagrantUp API token stored in `$HOME/.config/shell/private.sh` |

*Note: When creating a pull request that introduces new variables, please also open a pull request updating this table to reflect those changes. Include a short description of where and how the variable / secret is used in the description column.

## Creating New Variables / Secrets

If you want to expand the capabilities of your fork beyond what we have provided, we recommend you follow the same approach we use when handling environment variables and secret encrypted keys.

### Combining Variables and Secrets

Ideally, whenever possible, the user should be able to pass in a variable as either an environment variable or as a secret included in the fork. In the `$HOME/.config/shell/private.sh` file which houses private keys for cloud APIs that the user may want to source by running `. "$HOME/.config/shell/private.sh"`, the DockerHub token is defined with:

```shell
export DOCKERHUB_TOKEN="{{ if (stat (joinPath .chezmoi.sourceDir ".chezmoitemplates" "secrets" "key-DOCKERHUB_TOKEN")) }}{{ includeTemplate "secrets/key-DOCKERHUB_TOKEN" }}{{ else }}{{ env "DOCKERHUB_TOKEN" }}{{ end }}"
export DOCKERHUB_REGISTRY_PASSWORD="$DOCKERHUB_TOKEN"
```

This approach works well because it first checks for the presence of the `home/.chezmoitemplates/secrets/key-DOCKERHUB_TOKEN` file and then decrypts the value and injects it into the results `private.sh` file if the `key-DOCKERHUB_TOKEN` is present. Otherwise, it attempts to use the `DOCKERHUB_TOKEN` key.

*Note: Preferrably, you should store the secret as the same name as the corresponding environment variable.* That is, an environment variable named `DOCKERHUB_TOKEN` should be stored as a key stored in `home/.chezmoitemplates/secrets/key-DOCKERHUB_TOKEN`. Additionally, encrypted files that decrypt to files stored in `$HOME/.ssh/` should be prefixed with `ssh-` instead of `key-`.

### Encrypted Files

For encrypted files, you should mark the file as a templated file by ending the file name with `.tmpl` and then you should include a check to make sure both the decryption key and the encrypted secret data location is available. For example, our `$HOME/.ssh/id_rsa` file is generated by placing a file in `home/private_dot_ssh/private_id_rsa.tmpl` with the following content that makes these checks:

```shell
{{- if and (stat (joinPath .host.home ".config" "age" "chezmoi.txt")) (stat (joinPath .chezmoi.sourceDir ".chezmoitemplates" "secrets" "ssh-id-rsa")) -}}
{{   includeTemplate "secrets/ssh-id-rsa" | decrypt -}}
{{ end -}}
```

At provisioning time, if the necessary files are available, the encrypted secret data stored in `home/.chezmoitemplates/secrets/ssh-id-rsa` will be decrypted and added to the `$HOME/.ssh/id_rsa` file.